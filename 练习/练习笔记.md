# NOTES

## 绪论

1. 算法原地工作的含义是指辅助空间大小为 $O(1)$
2. 连续存储设计时，存储单元的地址一定连续
3. 汉诺塔递归的时间复杂度为 $O(2^{n})$
4. 数据结构不一定都具备三种基本运算(插入、删除和查找)

## 线性表

1. 存取意为存储(修改)和读取，不包含插入
2. 静态链表与动态链表相比，其缺点是有可能浪费较多存储空间
3. 在单链表中设置头结点的作用
   >有头结点之后，插入元素和删除元素的算法就统一了，不在需要判断是否在第一个元素之前插入元素和删除第一个元素。另外，不论链表是否为空，链表指针不变
4. 根据指针的连接方式，链表可分为动态链表和静态链表
5. 循环单链表的最大优势：从任一结点出发都可访问到链表中每一个元素

## 栈和队列

1. 在C语言中，**标识符** 是用来命名变量、函数、数组等程序实体的名称。标识符需要满足一定的规则和要求，这些规则包括：
    1. **字符集合：** 标识符由字母、数字和下划线组成。第一个字符必须是字母或下划线。
    2. **长度：** 标识符的长度没有限制，但大多数编译器对标识符的长度有限制，通常是31个字符。
    3. **大小写敏感：** C语言是大小写敏感的，因此大写字母和小写字母被认为是不同的字符。
    4. **关键字不能作为标识符：** C语言有一些关键字（例如if、else、while等），它们被用于特定的语法结构，不能用作标识符。
    5. **特殊字符：** 标识符不能包含空格、标点符号（除了下划线_）、运算符等特殊字符。
2. ‘+、-、*、/’优先级均低于“(”但高于“)”
3. 在中缀转前缀的时候，右优先原则的一个问题：华科2006一、5
   >并列的两个加法和并列的加法与减法并简单的不能用右优先，右优先其实相对于你的算法来说的。但是并不唯一，转化算法有很多。完全可以按照中缀的运算顺序来写算法，让栈的元素是字符串即可。
4. 同一组不重复输入序列执行不同的入出栈组合操作，所得结果也可能相同。
   >因为并未指明栈的状态，所以正确
5. 共享栈优点的一个表述[哈尔滨工程大学2005]
   >两个栈共享一个向量的优点是其中一个栈可用该空间的一半或以上
6. 链队列在出队时注意是否为空，会涉及尾指针的修改
7. 16进制 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8. 循环队列是队列的一种顺序存储结构
9. 循环队列的引入，是为了克服**假溢出时大量移动元素**
10. 区分循环队列的满与空:
  
    - 牺牲一个存储单元
    - 设标记
    - 设立计数器
11. 注意数字与字符的转换 `'0'+n`，`'0'`的ASCII码为48，`'a'`的ASCII码为97。

## 串

1. 对串进行修改操作的时候，记得指针指向的字符已经被修改过了。
2. 注意串长度为1的特殊情况。
3. 子串的数量为 $\dfrac{n\times (n+1)}{2}+1$
4. KMP算法的时间复杂度为 $O(m+n)$，其中 $O(n)$用于匹配 $O(m)$用于构建next(nextval)数组
5. 注意匹配次数和字符比较次数：前者是指匹配趟数后者指总的字符比较次数
6. 一种字符串拷贝的表达方式(浙大1999)

   ```c++
      void strcpy(char *s, char *t){
         while(*s++=*t++);/*也可以用(*s++=*t++)!='\0'*/
      }
   ```

7. KMP算法的优点：
   >主串指针不回溯。在经常发生“部分匹配”和主串很大不能一次性调入内存时，优点特别突出
8. 设S1、S2为串，请给出使S1//S2=S2//S1成立的所有可能条件(//为连接符)。

   ```text
   1. S1和S2至少一个是空串
   2.两串串值相等(即两串长度相等且对应位置上的字符相等)
   3.两串中一个串长是另一个串长(包括串长为1仅有一个字符的情况)的数倍，就像是由数个短串经过连接操作得到的。
   ```

9. 用字符串给数组赋初值会自动在最后加上`'\0'`，注意`'0'`会占位，算在数组长度里

## 数组和广义表

1. 数组通常具有的两种基本操作是`查找和修改`
2. 稀疏矩阵用三元组顺序表压缩存储时转置算法的时间复杂度
   >经典转置算法的时间复杂度为 $O(mu \times nu)$  
   >设置num和cpot两个向量的快速转置算法的时间复杂度是 $O(nu+tu)$
3. 稀疏矩阵的三元组存储方法对矩阵的非零元个数和位置在操作过程中变化不大时较有效，反之应该使用十字链表
4. 从逻辑结构上看，n维数组的每个元素均属于n个向量
5. 稀疏矩阵压缩存储后，必会失去随机存取功能
6. 数组在维数和上下界确定后，其元素个数已经确定，不能进行插入和删除运算
7. 二维以上的数组其实是一种特殊的广义表
   >该广义表的元素具有相同性质，属于同一数据对象。例如，n(n>1)维数组可以看成其元素是n-1维数组的广义表，广义表的元素都是n-1维数组
8. 线性表中的元素具有相同性质，属于同一数据对象。广义表中的元素有原子，有子表，不具有同一性质，因此严格说，广义表不是线性结构。但是，当广义表中的元素都是原子时，广义表退变成线性表。
9. 广义表A(b,A)的深度是无穷
   >A是一个无限递归的表
10. 重做数据结构1800 第五章 数组和广义表 填空31  
    ![ERROR](../Image/五_F31.png)
11. 对于正整数n，输出其和等于n且满足一下限制条件的所有正整数的和式，组成和式的数字自左至右构成一个非递增的序列

    ```c
      #define MAXN 100
      int a[MAXN];
      test(int n,int k){
         int i,j;
         for(j=n;j>=1;j--){
            a[k]=j;
            if(j==n){
               printf("%d=%d",a[0],a[1]);
               for(i=2;i<=k;i++) printf("+ %d",a[i]);
               printf("\n");
            }else test(n-j,k+1);
         }
      }
    ```

## 树和二叉树

:point_right: **树的所有有关计算的题目应紧紧把握分支和结点对应的数量关系**

1. 树的路径长度是从树根到每个结点的路径长度的**总和**
2. 设二叉树有2n个结点，且m<n，则不可能存在`2m`个度为1的结点
   >考察结点数的奇偶性
3. 二叉树是一种逻辑结构，线索二叉树是一种物理结构
4. 已知一颗有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点的个数是
   >对应二叉树中无右孩子的结点即为原树的每个分支结点的最右的子结点以及根节点，所以本题求得是分支结点数(每个分支结点必有一个无右孩子的子结点)+1
5. 二叉树是有序树，左右子树不可以任意交换
6. 在完全二叉树中， $n_{0}=n_{2}+1,n_{1}=0or1$
7. 由`二叉树的中序和先序`以及`中序和后序`都可以唯一确定一棵二叉树。此外，由`二叉树的中序序列和层次序列`也可以唯一确定一棵二叉树
8. 一棵完全二叉树又是一棵**平衡二叉树**
9. 二叉树不能简单地认为是 `每个结点至多有两棵子树的树`或者`每个结点至多有两棵子树的有序树`

    ```text
   树和二叉树均属于树形结构，其区别有三：一是二叉树的度至多为2，树无此限制；
   二是二叉树有左右子树之分，即使在只有一个分支的情况下，也必须指出是左子树还是右子树，树无此限制；
   三是二叉树允许为空，树一般不允许为空。
   二叉树不是树的特例。
    ```

10. n(n>0)个结点可以构造出 $\dfrac{(2n)!}{(n+1)(n!)^{2}}$种不同的二叉树。n个结点构造的不同的树的数量等于n-1个结点可以构造出的不同的二叉树的数量。
11. 答案:B
   ![ERROR](../Image/六_C107.png)
12. 答案:B
   ![ERROR](../Image/六_C108.png)

## 图

1. 一个无向图G是一棵树的条件是，G必须是无回路的连通图或有n-1条边的连通图
2. 一条有28条边的非连通无向图至少有()个顶点
   >考虑极端情况，即有一个连通图加一个孤立的点。由 $\dfrac{n\times (n-1)}{2}\geq 28$ 解得 $n=8$，加上孤立的点为9
3. 若无向图G=(V,E)中含有7个顶点，要保证图G在任何情况下都是连通的，则需要的边最少是
   >注意题干，要保证图G在任何情况下都是连通的，考虑最坏的情况，即其中六个顶点恰好构成一个完全图。即15+1=16
4. 答案：C  
   ![ERROR](../Image/六_C4.png)  
   每个结点对一条边的度数贡献为1
5. 有向图中，顶点的度为入度与出度之和
6. 区分极大连通子图和极小连通子图，前者要求包含其所有的边，后者相反
7. 图的深度优先遍历类似于树的先序遍历
8. 判断有向图中是否存在回路，可以采用`拓扑排序`和`深度优先遍历`
9. 对一个有n个顶点、e条边的图采用邻接表表示时，进行DFS遍历的时间复杂度为`O(n+e)`，空间复杂度为`O(n)`，进行BFS遍历的时间复杂度为`O(n+e)`，空间复杂度为`O(n)`
   >DFS用到一个辅助栈，BFS用到一个辅助队列
10. 若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为`三角`

    ```text
    可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序。  
    需要注意的是，若一个有向图的邻接矩阵为三角矩阵(对角线以上或以下的元素为0)，则图中必不存在环，因此其拓扑序列必然存在。
    ```

11. 下面是一种称为“破圈法”的求解最小生成树的方法：所谓破圈法，是指“任取一圈，去掉圈上权最大的边”，反复执行这一步骤，直到没有圈为止。

    ```text
      这种方法是正确的。  
    由于经过“破圈法”之后，最终没有回路，故一定可以构造出一棵生成树。  
      下面证明这棵生成树是最小生成树。  
    记“破圈法”生成的树为T，假设T不是最小生成树，则必然存在最小生成树T0，使得它与T的公共边尽可能地多，则将T0与T取并集，得到一个图，此图中必然存在回路，  
    由于“破圈法”的定义就是从回路中去除权最大的边，此时生成的T的权必然是最小的，这与原假设T不是最小生成树矛盾，从而T是最小生成树。
    ```

12. 在具有n个顶点的图G中，若最小生成树不唯一，则`G的边数一定大于n-1`
13. 在有向图中，一个节点的出度（Out-Degree）表示从该节点发出的边的数量。如果一个节点的出度为0，意味着没有任何边从该节点发出。在这种情况下，该节点被称为终端节点（Terminal Node）或叶子节点（Leaf Node）。
14. 若从 $v_{0}$开始对有向图g进行深度遍历的序列唯一，则可唯一确定该图 ❌
    >孤立结点或者结点的弧指向集团中的某个节点
15. 如果拓扑排序序列是唯一的，那么只有一个顶点的出度为0，只有一个顶点的入度为0。
16. 无权值的无向图和有向图的邻接矩阵是对称矩阵，可压缩存储：n个顶点所需存储空间为 $\dfrac{n\times (n-1)}{2}$
    >注意，对角线元素不用存储
17. 已知具有 $n(n\geq 2)$ 个顶点的邻接矩阵为 $B$，则 $B^{m}(2\leq m\leq n)$ 非零元素的含义是，两顶点间长度为m的路径条数
18. 二部图的邻接矩阵是分块对称矩阵
19. 如何对有向图的顶点适当地编号可使得该图的邻接矩阵中所有的1都集中到对角线以上？
    >1、按各顶点的出度进行排序。n个顶点的有向图其顶点的最大出度是n-1，最小出度为0。这样排序后，出度最大的顶点编号为0，出度最小的顶点编号为n-1。之后，进行调整，即若存在弧<i,j>，不论顶点j的出度是否大于i的出度，都要把顶点j的编号排在顶点i的编号之后，这样<i,j>对应的1才能排到邻接矩阵的上三角。  
    >2、按照拓扑排序编号是一种更为简单的方式
20. 表示一个有1000个顶点、1000条边的有向图的邻接矩阵是否为稀疏矩阵
    >按照书上计算 e<nlog(n)，可以认为是稀疏矩阵，但是作者说，稀疏矩阵的定义是矩阵中的非零元素远少于矩阵元素的数量，且分布无规律，因此不能认为是稀疏矩阵。

## 动态分配存储

1. 在各种模拟伙伴系统分配空间的题中，需要关注回收之后是否需要合并，若合并，还需注意是否需要二次合并
2. 在模拟边界标识法的过程中，遇到回收空间的情况，需判断**左右两个块**是否均需要合并，不要漏掉左合并或者右合并

## 查找

1. 计算哈希表的平均查找长度时，注意
   - 在空位置上的查询也算在关键字对比次数里
   - 注意散列函数的值域
2. B+树是应文件系统所需而产生的B-树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者磁盘读写代价更低，查询效率更加稳定。
3. 处理冲突(碰撞)时避免产生聚集(堆积现象)❌
   >只能减少，不能避免
4. 为提高散列表的查询效率，可以采取的正确措施有`减小填充因子`和`设计冲突(碰撞)少的散列函数`
5. **存储效率**是指**哈希表中实际存储的元素个数与哈希表长度的比值**
6. 如果要求一个线性表既能较快地查找，又能适应动态变化地要求，可以采用**分块查找**的方法
7. 注意区别，采用链地址法解决冲突地哈希表中，查找成功的平均查找长度**直接与装填因子有关**
   >注意此时不是选择装填因子
8. 平衡二叉树只限制了平衡因子，并不需要有序
9. 一棵平衡二叉树中的任意两个叶子结点的层次差的绝对值不大于1❌

    ```text
             2
            / \
          -1   0
          / \
         0   1
            /
           0
    ```

10. 开哈希表-------链式地址法  闭哈希表-------开放地址法 装填因子增大，意味着哈希表的空间利用率在增大。开哈希和闭哈希主要的区别在于，随着哈希表的密集度提高，使用闭哈希时，不仅会与相同哈希值的元素发生冲突，还容易与不同哈希值的元素发生冲突；而开哈希则不受哈希表疏密与否的影响，始终只会与相同哈希值的元素冲突而已。所以在密集度变大的哈希表中查找时，显然开哈希的平均搜索长度不会增长。(清华2002)
11. 再次强调，B-tree叶子层也算高度
12. 具有n个关键字的B-树的查找路径长度不会大于 $h\leq \log_{\lceil m/2\rceil}\frac{n+1}{2}+1$
13. 监视哨的作用是免去查找过程中每次都要检测整个表是否查找完毕，提高了查找效率。
14. 计算平均查找长度，一个常用的方法是**错位相减**
15. 用关键字为1，2，3，4的四个结点能构造出几种不同的二叉排序树
    >实质上是给定1、2、3、4，有几种不同的二叉排序树，即该中序序列相当于多少种不同的前序序列，这是树的计数问题。设中序序列中元素数为n，则二叉树的数目为 $\dfrac{1}{n+1}C_{2n}^{n}$
16. 注意哈希函数是取余运算，即是一个循环数组

## 排序

1. 对10TB的数据文件进行排序，应使用的方法是：  
    A.希尔排序   B.堆排序   C.快速排序   D.归并排序
    >10TB很大要选外部排序
2. 下列排序算法中,()每一趟都能选出一个元素放在其最终位置上，并且是不稳定的  
    A.冒泡排序  B.希尔排序 C.简单选择排序 D.快速排序
3. 基数排序适用于整数，不适用于实数
4. 比较次数 与序列初态 无关 的算法是：二路归并排序、简单选择排序、基数排序  
    比较次数 与序列初态 有关 的算法是：快速排序、直接插入排序、冒泡排序、堆排序、希尔排序  
    排序趟数 与序列初态 无关 的算法是：直接插入排序、折半插入排序、希尔排序、简单选择排序、归并排序、基数排序  
    排序趟数 与序列初态 有关 的算法是：冒泡排序、快速排序  
5. 在初始序列已基本有序(除去n个元素中的某k个元素后即呈有序， $k\leq n$)的情况下，排序效率最高的算法是**直接插入排序**
6. 在初始序列已基本有序的情况下，快速排序可以看成退化为冒泡排序
7. 在评估空间复杂度的时候，不仅要注意辅助空间，还要注意快速排序的递归
8. 采用败者树进行K路平衡归并时，总的(包括访外)归并效率与K**有关**
   >从归并次数的公式 $\lfloor \log_2{m} \rfloor (n-1)$看，比较次数与归并路数k无关，似乎k越大越好。但对于具体机器来说，内存是固定的，k越大，缓冲区越多，每个缓冲区就越小，甚至小于一次I/O读写空间。因而总的归并效率仍与k有关。k应取中值，并非越大越好
9. 二分法插入排序所需的比较次数与待排序记录的初始排列状态相关❌
    >因为要在已有序的子文件中折半查找插入位置，这种查找都要查到外部结点，因此二分法插入排序所需的比较次数与待排序记录的初始排列状态无关
10. 堆不是树
11. 假设工作区的容量为 $w$，则置换-选择排序法所得初始归并段长度的期望值为 $2w$。容易看出，若不计输入、输出的时间，则对n个记录的文件而言，生成所有初始归并段所需时间为 $O(n\log{w})$

## 文件

1. 若在磁盘上的顺序文件中插入新的记录，不一定要复制整个文件❌
2. 对处理大量数据的外存介质而言，索引顺序存储方法是一种方便的文件组织方法❌

## 用栈模拟递归

1. 用for或者while循环语句
2. 只保留未运行完的函数的相应信息，return语句可以之后操作

## 环的数量与最大公约数(详见5.18哈希思想)

假设有一个环，其中有 `n` 个元素，每个元素移动 `k` 个位置。我们希望探讨环的数量与最大公约数之间的关系。

```plaintext
环的数量 = gcd(n, k)
```

其中，`gcd` 表示最大公约数函数。
这个关系的解释是，当元素移动的步长 `k` 和环的长度 `n` 的最大公约数大于1时，就会形成环。因此，环的数量等于 `gcd(n, k)`。

## BST序列种类

先确定结点序列的相对位置，再用全排列消除其他错误的序列

> 严书题集9.10:
> 确定7、6，4、2、1(3)的相对的相对位置，则计算公式为
> $$\dfrac{A_{7}^{7}A_{2}^{2}}{A_{2}^{2}A_{4}^{4}}$$
> 其中分母的 $A_{2}^{2}$表示4、2的相对位置，分子的 $A_{2}^{2}$表示1、3的排列组合

## 深度为h的平衡二叉树所具有的最少节点数

假设以 $N_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然, $N_0=0, N_1=1, N_2=$ 2 , 并且 $N_h=N_{h-1}+N_{h-2}+1$ 。
