# NOTES

## 绪论

1. 算法原地工作的含义是指辅助空间大小为 $O(1)$
2. 连续存储设计时，存储单元的地址一定连续
3. 汉诺塔递归的时间复杂度为 $O(2^{n})$
4. 数据结构不一定都具备三种基本运算(插入、删除和查找)

## 线性表

1. 存取意为存储(修改)和读取，不包含插入
2. 静态链表与动态链表相比，其缺点是有可能浪费较多存储空间
3. 在单链表中设置头结点的作用
   >有头结点之后，插入元素和删除元素的算法就统一了，不在需要判断是否在第一个元素之前插入元素和删除第一个元素。另外，不论链表是否为空，链表指针不变
4. 根据指针的连接方式，链表可分为动态链表和静态链表
5. 循环单链表的最大优势：从任一结点出发都可访问到链表中每一个元素

## 栈和队列

1. 在C语言中，**标识符** 是用来命名变量、函数、数组等程序实体的名称。标识符需要满足一定的规则和要求，这些规则包括：
    1. **字符集合：** 标识符由字母、数字和下划线组成。第一个字符必须是字母或下划线。
    2. **长度：** 标识符的长度没有限制，但大多数编译器对标识符的长度有限制，通常是31个字符。
    3. **大小写敏感：** C语言是大小写敏感的，因此大写字母和小写字母被认为是不同的字符。
    4. **关键字不能作为标识符：** C语言有一些关键字（例如if、else、while等），它们被用于特定的语法结构，不能用作标识符。
    5. **特殊字符：** 标识符不能包含空格、标点符号（除了下划线_）、运算符等特殊字符。
2. ‘+、-、*、/’优先级均低于“(”但高于“)”
3. 在中缀转前缀的时候，右优先原则的一个问题：华科2006一、5
   >并列的两个加法和并列的加法与减法并简单的不能用右优先，右优先其实相对于你的算法来说的。但是并不唯一，转化算法有很多。完全可以按照中缀的运算顺序来写算法，让栈的元素是字符串即可。
4. 同一组不重复输入序列执行不同的入出栈组合操作，所得结果也可能相同。
   >因为并未指明栈的状态，所以正确
5. 共享栈优点的一个表述[哈尔滨工程大学2005]
   >两个栈共享一个向量的优点是其中一个栈可用该空间的一半或以上
6. 链队列在出队时注意是否为空，会涉及尾指针的修改
7. 16进制 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8. 循环队列是队列的一种顺序存储结构
9. 循环队列的引入，是为了克服**假溢出时大量移动元素**
10. 区分循环队列的满与空:
  
    - 牺牲一个存储单元
    - 设标记
    - 设立计数器
11. 注意数字与字符的转换 `'0'+n`，`'0'`的ASCII码为48，`'a'`的ASCII码为97。

## 串

1. 对串进行修改操作的时候，记得指针指向的字符已经被修改过了。
2. 注意串长度为1的特殊情况。
3. 子串的数量为 $\dfrac{n\times (n+1)}{2}+1$
4. KMP算法的时间复杂度为 $O(m+n)$，其中 $O(n)$用于匹配 $O(m)$用于构建next(nextval)数组
5. 注意匹配次数和字符比较次数：前者是指匹配趟数后者指总的字符比较次数
6. 一种字符串拷贝的表达方式(浙大1999)

   ```c++
      void strcpy(char *s, char *t){
         while(*s++=*t++);/*也可以用(*s++=*t++)!='\0'*/
      }
   ```

7. KMP算法的优点：
   >主串指针不回溯。在经常发生“部分匹配”和主串很大不能一次性调入内存时，优点特别突出
8. 设S1、S2为串，请给出使S1//S2=S2//S1成立的所有可能条件(//为连接符)。

   ```text
   1. S1和S2至少一个是空串
   2.两串串值相等(即两串长度相等且对应位置上的字符相等)
   3.两串中一个串长是另一个串长(包括串长为1仅有一个字符的情况)的数倍，就像是由数个短串经过连接操作得到的。
   ```

9. 用字符串给数组赋初值会自动在最后加上`'\0'`，注意`'0'`会占位，算在数组长度里

## 数组和广义表

1. 数组通常具有的两种基本操作是`查找和修改`
2. 稀疏矩阵用三元组顺序表压缩存储时转置算法的时间复杂度
   >经典转置算法的时间复杂度为 $O(mu \times nu)$  
   >设置num和cpot两个向量的快速转置算法的时间复杂度是 $O(nu+tu)$
3. 稀疏矩阵的三元组存储方法对矩阵的非零元个数和位置在操作过程中变化不大时较有效，反之应该使用十字链表
4. 从逻辑结构上看，n维数组的每个元素均属于n个向量
5. 稀疏矩阵压缩存储后，必会失去随机存取功能
6. 数组在维数和上下界确定后，其元素个数已经确定，不能进行插入和删除运算
7. 二维以上的数组其实是一种特殊的广义表
   >该广义表的元素具有相同性质，属于同一数据对象。例如，n(n>1)维数组可以看成其元素是n-1维数组的广义表，广义表的元素都是n-1维数组
8. 线性表中的元素具有相同性质，属于同一数据对象。广义表中的元素有原子，有子表，不具有同一性质，因此严格说，广义表不是线性结构。但是，当广义表中的元素都是原子时，广义表退变成线性表。
9. 广义表A(b,A)的深度是无穷
   >A是一个无限递归的表
10. 重做数据结构1800 第五章 数组和广义表 填空31  
    ![ERROR](/Image/5-填空-31.png)
11. 对于正整数n，输出其和等于n且满足一下限制条件的所有正整数的和式，组成和式的数字自左至右构成一个非递增的序列

    ```c
      #define MAXN 100
      int a[MAXN];
      test(int n,int k){
         int i,j;
         for(j=n;j>=1;j--){
            a[k]=j;
            if(j==n){
               printf("%d=%d",a[0],a[1]);
               for(i=2;i<=k;i++) printf("+ %d",a[i]);
               printf("\n");
            }else test(n-j,k+1);
         }
      }
    ```

## 图

1. 一个无向图G是一棵树的条件是，G必须是无回路的连通图或有n-1条边的连通图

## 用栈模拟递归

1. 用for或者while循环语句
2. 只保留未运行完的函数的相应信息，return语句可以之后操作

## 环的数量与最大公约数(详见5.18哈希思想)

假设有一个环，其中有 `n` 个元素，每个元素移动 `k` 个位置。我们希望探讨环的数量与最大公约数之间的关系。

```plaintext
环的数量 = gcd(n, k)
```

其中，`gcd` 表示最大公约数函数。
这个关系的解释是，当元素移动的步长 `k` 和环的长度 `n` 的最大公约数大于1时，就会形成环。因此，环的数量等于 `gcd(n, k)`。

## BST序列种类

先确定结点序列的相对位置，再用全排列消除其他错误的序列

> 严书题集9.10:
> 确定7、6，4、2、1(3)的相对的相对位置，则计算公式为
> $$\dfrac{A_{7}^{7}A_{2}^{2}}{A_{2}^{2}A_{4}^{4}}$$
> 其中分母的 $A_{2}^{2}$表示4、2的相对位置，分子的 $A_{2}^{2}$表示1、3的排列组合

## 深度为h的平衡二叉树所具有的最少节点数

假设以 $N_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然, $N_0=0, N_1=1, N_2=$ 2 , 并且 $N_h=N_{h-1}+N_{h-2}+1$ 。
