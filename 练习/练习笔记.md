# NOTES

## 绪论

1. 算法原地工作的含义是指辅助空间大小为 $O(1)$
2. 连续存储设计时，存储单元的地址一定连续
3. 汉诺塔递归的时间复杂度为 $O(2^{n})$
4. 数据结构不一定都具备三种基本运算(插入、删除和查找)

## 线性表

1. 存取意为存储(修改)和读取，不包含插入
2. 静态链表与动态链表相比，其缺点是有可能浪费较多存储空间
3. 在单链表中设置头结点的作用
   >有头结点之后，插入元素和删除元素的算法就统一了，不在需要判断是否在第一个元素之前插入元素和删除第一个元素。另外，不论链表是否为空，链表指针不变
4. 根据指针的连接方式，链表可分为动态链表和静态链表
5. 循环单链表的最大优势：从任一结点出发都可访问到链表中每一个元素

## 栈和队列

1. 在C语言中，**标识符** 是用来命名变量、函数、数组等程序实体的名称。标识符需要满足一定的规则和要求，这些规则包括：
    1. **字符集合：** 标识符由字母、数字和下划线组成。第一个字符必须是字母或下划线。
    2. **长度：** 标识符的长度没有限制，但大多数编译器对标识符的长度有限制，通常是31个字符。
    3. **大小写敏感：** C语言是大小写敏感的，因此大写字母和小写字母被认为是不同的字符。
    4. **关键字不能作为标识符：** C语言有一些关键字（例如if、else、while等），它们被用于特定的语法结构，不能用作标识符。
    5. **特殊字符：** 标识符不能包含空格、标点符号（除了下划线_）、运算符等特殊字符。
2. ‘+、-、*、/’优先级均低于“(”但高于“)”
3. 在中缀转前缀的时候，右优先原则的一个问题：华科2006一、5
   >并列的两个加法和并列的加法与减法并简单的不能用右优先，右优先其实相对于你的算法来说的。但是并不唯一，转化算法有很多。完全可以按照中缀的运算顺序来写算法，让栈的元素是字符串即可。
4. 同一组不重复输入序列执行不同的入出栈组合操作，所得结果也可能相同。
   >因为并未指明栈的状态，所以正确
5. 共享栈优点的一个表述[哈尔滨工程大学2005]
   >两个栈共享一个向量的优点是其中一个栈可用该空间的一半或以上
6. 链队列在出队时注意是否为空，会涉及尾指针的修改
7. 16进制 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8. 循环队列是队列的一种顺序存储结构
9. 循环队列的引入，是为了克服**假溢出时大量移动元素**
10. 区分循环队列的满与空:
  
    - 牺牲一个存储单元
    - 设标记
    - 设立计数器
11. 注意数字与字符的转换 `'0'+n`，`'0'`的ASCII码为48，`'a'`的ASCII码为97。

## 串

1. 对串进行修改操作的时候，记得指针指向的字符已经被修改过了。
2. 注意串长度为1的特殊情况。
3. 子串的数量为 $\dfrac{n\times (n+1)}{2}+1$
4. KMP算法的时间复杂度为 $O(m+n)$，其中 $O(n)$用于匹配 $O(m)$用于构建next(nextval)数组
5. 注意匹配次数和字符比较次数：前者是指匹配趟数后者指总的字符比较次数
6. 一种字符串拷贝的表达方式(浙大1999)

   ```c++
      void strcpy(char *s, char *t){
         while(*s++=*t++);/*也可以用(*s++=*t++)!='\0'*/
      }
   ```

7. KMP算法的优点：
   >主串指针不回溯。在经常发生“部分匹配”和主串很大不能一次性调入内存时，优点特别突出
8. 设S1、S2为串，请给出使S1//S2=S2//S1成立的所有可能条件(//为连接符)。

   ```text
   1. S1和S2至少一个是空串
   2.两串串值相等(即两串长度相等且对应位置上的字符相等)
   3.两串中一个串长是另一个串长(包括串长为1仅有一个字符的情况)的数倍，就像是由数个短串经过连接操作得到的。
   ```

9. 用字符串给数组赋初值会自动在最后加上`'\0'`，注意`'0'`会占位，算在数组长度里

## 数组和广义表

1. 数组通常具有的两种基本操作是`查找和修改`
2. 稀疏矩阵用三元组顺序表压缩存储时转置算法的时间复杂度
   >经典转置算法的时间复杂度为 $O(mu \times nu)$  
   >设置num和cpot两个向量的快速转置算法的时间复杂度是 $O(nu+tu)$
3. 稀疏矩阵的三元组存储方法对矩阵的非零元个数和位置在操作过程中变化不大时较有效，反之应该使用十字链表
4. 从逻辑结构上看，n维数组的每个元素均属于n个向量
5. 稀疏矩阵压缩存储后，必会失去随机存取功能
6. 数组在维数和上下界确定后，其元素个数已经确定，不能进行插入和删除运算
7. 二维以上的数组其实是一种特殊的广义表
   >该广义表的元素具有相同性质，属于同一数据对象。例如，n(n>1)维数组可以看成其元素是n-1维数组的广义表，广义表的元素都是n-1维数组
8. 线性表中的元素具有相同性质，属于同一数据对象。广义表中的元素有原子，有子表，不具有同一性质，因此严格说，广义表不是线性结构。但是，当广义表中的元素都是原子时，广义表退变成线性表。
9. 广义表A(b,A)的深度是无穷
   >A是一个无限递归的表
10. 重做数据结构1800 第五章 数组和广义表 填空31  
    ![ERROR](../Image/五_F31.png)
11. 对于正整数n，输出其和等于n且满足一下限制条件的所有正整数的和式，组成和式的数字自左至右构成一个非递增的序列

    ```c
      #define MAXN 100
      int a[MAXN];
      test(int n,int k){
         int i,j;
         for(j=n;j>=1;j--){
            a[k]=j;
            if(j==n){
               printf("%d=%d",a[0],a[1]);
               for(i=2;i<=k;i++) printf("+ %d",a[i]);
               printf("\n");
            }else test(n-j,k+1);
         }
      }
    ```

## 树和二叉树

:point_right: **树的所有有关计算的题目应紧紧把握分支和结点对应的数量关系**

1. 树的路径长度是从树根到每个结点的路径长度的**总和**
2. 设二叉树有2n个结点，且m<n，则不可能存在`2m`个度为1的结点
   >考察结点数的奇偶性
3. 二叉树是一种逻辑结构，线索二叉树是一种物理结构
4. 已知一颗有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点的个数是
   >对应二叉树中无右孩子的结点即为原树的每个分支结点的最右的子结点以及根节点，所以本题求得是分支结点数(每个分支结点必有一个无右孩子的子结点)+1
5. 二叉树是有序树，左右子树不可以任意交换
6. 在完全二叉树中， $n_{0}=n_{2}+1,n_{1}=0or1$
7. 由`二叉树的中序和先序`以及`中序和后序`都可以唯一确定一棵二叉树。此外，由`二叉树的中序序列和层次序列`也可以唯一确定一棵二叉树
8. 一棵完全二叉树又是一棵**平衡二叉树**
9. 二叉树不能简单地认为是 `每个结点至多有两棵子树的树`或者`每个结点至多有两棵子树的有序树`

    ```text
   树和二叉树均属于树形结构，其区别有三：一是二叉树的度至多为2，树无此限制；
   二是二叉树有左右子树之分，即使在只有一个分支的情况下，也必须指出是左子树还是右子树，树无此限制；
   三是二叉树允许为空，树一般不允许为空。
   二叉树不是树的特例。
    ```

10. n(n>0)个结点可以构造出 $\dfrac{(2n)!}{(n+1)(n!)^{2}}$种不同的二叉树。n个结点构造的不同的树的数量等于n-1个结点可以构造出的不同的二叉树的数量。
11. 答案:B
   ![ERROR](../Image/六_C107.png)
12. 答案:B
   ![ERROR](../Image/六_C108.png)

## 图

1. 一个无向图G是一棵树的条件是，G必须是无回路的连通图或有n-1条边的连通图
2. 一条有28条边的非连通无向图至少有()个顶点
   >考虑极端情况，即有一个连通图加一个孤立的点。由 $\dfrac{n\times (n-1)}{2}\geq 28$ 解得 $n=8$，加上孤立的点为9
3. 若无向图G=(V,E)中含有7个顶点，要保证图G在任何情况下都是连通的，则需要的边最少是
   >注意题干，要保证图G在任何情况下都是连通的，考虑最坏的情况，即其中六个顶点恰好构成一个完全图。即15+1=16
4. 答案：C  
   ![ERROR](../Image/六_C4.png)  
   每个结点对一条边的度数贡献为1
5. 有向图中，顶点的度为入度与出度之和
6. 区分极大连通子图和极小连通子图，前者要求包含其所有的边，后者相反
7. 图的深度优先遍历类似于树的先序遍历
8. 判断有向图中是否存在回路，可以采用`拓扑排序`和`深度优先遍历`
9. 对一个有n个顶点、e条边的图采用邻接表表示时，进行DFS遍历的时间复杂度为`O(n+e)`，空间复杂度为`O(n)`，进行BFS遍历的时间复杂度为`O(n+e)`，空间复杂度为`O(n)`
   >DFS用到一个辅助栈，BFS用到一个辅助队列
10. 若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为`三角`

    ```text
    可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序。  
    需要注意的是，若一个有向图的邻接矩阵为三角矩阵(对角线以上或以下的元素为0)，则图中必不存在环，因此其拓扑序列必然存在。
    ```

11. 下面是一种称为“破圈法”的求解最小生成树的方法：所谓破圈法，是指“任取一圈，去掉圈上权最大的边”，反复执行这一步骤，直到没有圈为止。

    ```text
      这种方法是正确的。  
    由于经过“破圈法”之后，最终没有回路，故一定可以构造出一棵生成树。  
      下面证明这棵生成树是最小生成树。  
    记“破圈法”生成的树为T，假设T不是最小生成树，则必然存在最小生成树T0，使得它与T的公共边尽可能地多，则将T0与T取并集，得到一个图，此图中必然存在回路，  
    由于“破圈法”的定义就是从回路中去除权最大的边，此时生成的T的权必然是最小的，这与原假设T不是最小生成树矛盾，从而T是最小生成树。
    ```

12. 在具有n个顶点的图G中，若最小生成树不唯一，则`G的边数一定大于n-1`
13. 在有向图中，一个节点的出度（Out-Degree）表示从该节点发出的边的数量。如果一个节点的出度为0，意味着没有任何边从该节点发出。在这种情况下，该节点被称为终端节点（Terminal Node）或叶子节点（Leaf Node）。
14. 若从 $v_{0}$开始对有向图g进行深度遍历的序列唯一，则可唯一确定该图 ❌
    >孤立结点或者结点的弧指向集团中的某个节点
15. 如果拓扑排序序列是唯一的，那么只有一个顶点的出度为0，只有一个顶点的入度为0。
16. 无权值的无向图和有向图的邻接矩阵是对称矩阵，可压缩存储：n个顶点所需存储空间为 $\dfrac{n\times (n-1)}{2}$
    >注意，对角线元素不用存储
17. 已知具有 $n(n\geq 2)$ 个顶点的邻接矩阵为 $B$，则 $B^{m}(2\leq m\leq n)$ 非零元素的含义是，两顶点间长度为m的路径条数
18. 二部图的邻接矩阵是分块对称矩阵
19. 如何对有向图的顶点适当地编号可使得该图的邻接矩阵中所有的1都集中到对角线以上？
    >1、按各顶点的出度进行排序。n个顶点的有向图其顶点的最大出度是n-1，最小出度为0。这样排序后，出度最大的顶点编号为0，出度最小的顶点编号为n-1。之后，进行调整，即若存在弧<i,j>，不论顶点j的出度是否大于i的出度，都要把顶点j的编号排在顶点i的编号之后，这样<i,j>对应的1才能排到邻接矩阵的上三角。  
    >2、按照拓扑排序编号是一种更为简单的方式
20. 表示一个有1000个顶点、1000条边的有向图的邻接矩阵是否为稀疏矩阵
    >按照书上计算 $e<n\log{n}$，可以认为是稀疏矩阵，但是作者说，稀疏矩阵的定义是矩阵中的非零元素远少于矩阵元素的数量，且分布无规律，因此不能认为是稀疏矩阵。

## 用栈模拟递归

1. 用for或者while循环语句
2. 只保留未运行完的函数的相应信息，return语句可以之后操作

## 环的数量与最大公约数(详见5.18哈希思想)

假设有一个环，其中有 `n` 个元素，每个元素移动 `k` 个位置。我们希望探讨环的数量与最大公约数之间的关系。

```plaintext
环的数量 = gcd(n, k)
```

其中，`gcd` 表示最大公约数函数。
这个关系的解释是，当元素移动的步长 `k` 和环的长度 `n` 的最大公约数大于1时，就会形成环。因此，环的数量等于 `gcd(n, k)`。

## BST序列种类

先确定结点序列的相对位置，再用全排列消除其他错误的序列

> 严书题集9.10:
> 确定7、6，4、2、1(3)的相对的相对位置，则计算公式为
> $$\dfrac{A_{7}^{7}A_{2}^{2}}{A_{2}^{2}A_{4}^{4}}$$
> 其中分母的 $A_{2}^{2}$表示4、2的相对位置，分子的 $A_{2}^{2}$表示1、3的排列组合

## 深度为h的平衡二叉树所具有的最少节点数

假设以 $N_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然, $N_0=0, N_1=1, N_2=$ 2 , 并且 $N_h=N_{h-1}+N_{h-2}+1$ 。
