# 排序

## 排序的基本概念

- 将各元素按关键字递增/或递减顺序重新排列
- 评价指标
  - 稳定性：关键字相同的元素经过排序后相对顺序是否会改变
  - 时间复杂度、空间复杂度
- 分类
  - 内部排序：数据都在内存中
  - 外部排序：数据太多，无法全部放入内存中，需考虑磁盘读取次数

## 插入排序

### 插入排序(传统)

#### 算法实现

```c++
    //直接插入排序
    void InsertSort(int A[],int n){
        int i,j,temp;
        for(i=1;i<n;i++)
            if(A[i]<A[i-1]){
                temp=A[i];
                for(j=i-1;j>=0&&A[j]>temp;--j)
                    A[j+1]=A[j];
                A[j+1]=temp;
            }
    }

    //直接插入排序(带哨兵)
    void InsertSort(int A[],int n){
        int i,j;
        for(i=2;i<=n;i++)
            if(A[i]<A[i-1]){
                A[0]=A[i];
                for(j=i-1;A[0]<A[j];j--){
                    A[j+1]=A[j];
                }
                A[j+1]=A[0];
            }
    }
```

#### 算法效率分析

- 空间复杂度： $O(1)$
- 时间复杂度
  - 最好时间复杂度(顺序)： $O(n)$
  - 最坏时间复杂度(逆序)： $O(n^{2})$
  - 平均时间复杂度： $O(n^{2})$
- 算法稳定性：稳定

#### 优化算法

```c++
    //折半插入排序
    void InsertSort(int A[],int n)
        int i,j,low,high,mid;
        for(i=2;i<=n;i++){
            A[0]=A[i];
            low=1;high=i-1;
            while(low<=high){
                mid=(low+high)/2;
                if(A[mid]>A[0]) high=mid-1;
                else  low=mid+1;
            }
            for(j=i-1;j>=low;--j)
                A[j+1]=A[j];
            A[low]=A[0];
        }
```

比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度仍然是 $O(n^{2})$

### 希尔排序

#### 希尔排序的算法实现

```c++
    //希尔排序
    void ShellSort(int A[],int n){
        int d,i,j;
        //A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
        for(d=n/2;d>=1;d=d/2)   //步长变化
            for(i=d+1;i<=n;++i)
                if(A[i]<A[i-d]){
                    A[0]=A[i];
                    for(j=i-d;j>0 && A[0]<A[j]; j-=d)
                        A[j+d]=A[j];
                    A[j+d]=A[0];
                }
    }

```

#### 希尔排序性能分析

- 空间复杂度：$O(1)$
- 时间复杂度：和增量序列的选择有关，最坏时间复杂度为 $O(n^{2})$，当n在某个范围时，可达 $O(n^{1.3})$
- 稳定性：不稳定
- 适用性：仅适用于顺序表，不适用于链表

## 交换排序

### 冒泡排序

#### 冒泡排序算法实现

```c++
    //交换
    void swap(int &a,int &b){
        int temp=a;
        a=b;
        b=temp;
    }

    //冒泡排序
    void BubbleSort(int A[],int n){
        for(int i=0;i<n-1;i++){
            bool flag=false;
            for(int j=n-1;j<i;j--)
                if(A[j-1]>A[j]){
                    swap(A[j-1],A[j]);
                    flag=true;
                }
            if(flag=false)
                return;        
        }    
    }
```

#### 冒泡排序性能分析

- 空间复杂度： $O(1)$
- 时间复杂度
  - 最好情况(有序)：比较次数= $n-1$，交换次数= $0$，最好时间复杂度= $O(n)$
  - 最坏情况(逆序)：比较次数=交换次数= $(n-1)+(n-2)+\cdots+1=\dfrac{n(n-1)}{2}$，最坏时间复杂度= $O(n^{2})$
  - 平均时间复杂度= $O(n^{2})$
- 稳定性：稳定的
- 适用性：适用于链表

### 快速排序

#### 快速排序算法实现

```c++
    //用第一个元素将待排序序列划分为左右两个部分
    int Partition(int A[],int low,int high){
        int pivot=A[low];
        while(low<high){
            while(low<high&&A[high]>=pivot) high--;
            A[low]=A[high];
            while(low<high&&A[low]<=pivot)  low++;
            A[high]=A[low];
        }
        A[low]=pivot;
        return low;
    }

    //快速排序
    void QuickSort(int A[],int low,int high){
        if(low<high){
            int pivotpos=Partition(A[],low,high);
            QuickSort(A,low,pivotpos-1);
            QuickSort(A,pivotpos+1,high);
        }
    }
```

#### 快速排序算法效率分析

- 时间复杂度 $=O(n\times\text{递归层数})$
  - 最好时间复杂度 $=O(n\log_2{n})$ $\rightarrow$ 每次选的枢轴元素都能将序列划分成均匀的两部分
    - 选头、中、尾三个位置的元素，取中间值作为枢轴元素
    - 随机选一个元素作为枢轴元素
  - 最坏时间复杂度 $=O(n^{2})$ $\rightarrow$ 若序列原本就有序或者逆序，则时间复杂度、空间复杂度最高(可优化，尽量选择可以把数据中分的枢轴元素)
  - 平均时间复杂度 $=O(n^{2})$**快速排序是所有内部排序算法中平均性能最优的排序算法**
- 空间复杂度 $=O(\text{递归层数})$
  - 最好空间复杂度 $=O(n\log_2{n})$ $\rightarrow$
  - 最坏空间复杂度 $=O(n)$
- 稳定性：不稳定

#### tips

关注“一趟”排序和一次“划分”是否相同
