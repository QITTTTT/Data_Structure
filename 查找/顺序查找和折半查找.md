# 顺序查找和折半查找

## 顺序查找

时间复杂度：$O(n)$

### 顺序查找的实现

#### 哨兵算法

    typedef struct{
        ElemType *elem;    //动态数组基址
        int TableLen;      //表的长度
    }SSTable               //Sparse Sorted Table

    //顺序查找
    int Search_Seq(SSTable ST,ElemType key){
        ST.elem[0]=key;    //哨兵
        int i;
        for(i=ST.Tablelen;ST.elem[i]!=key;--i);
        return i;
    }

#### 执行效率(ASL)

- 查找成功: $ASL_{成功}=\frac{n+1}{2}$ -- $O(n)$
- 查找失败：$ASL_{失败}=n+1$

### 顺序查找的优化

#### 查找判定树(有序表)

$ASL_{失败}=\frac{n}{2}+\frac{n}{n+1}$ -- $O(n)$

#### 被查概率大的放在靠前位置(被查概率不相等)

## 折半查找(仅适用于有序的顺序表)

### 折半查找的实现

    typedef struct{
        ElemType *elem;
        int TableLen;
    }SSTable;

    //折半查找
    int Binary_Search(SSTable L,ElemType key){
        int low=0,high=L.TableLen-1,mid;
        while(low<=high){
            mid=(low+high)/2;
            if(L.elem[mid]==key)
                return mid;
            if(L.elem[mid]<key)
                low=mid+1;
            else
                high=mid-1;
        }
        return -1;
    }

### 查找效率分析

时间复杂度：$O(log_2{n})$

折半查找的速度~~一定~~大多数情况下比顺序查找更快

#### 折半查找判定树的构造

- 右子树结点树-左子树结点树=0或1
- 折半查找的判定树**一定是平衡二叉树**
- 折半查找的判定树中，**只有最下面一层是不满的**,因此元素个数为n时**树高 $h=\lceil log_2{n+1} \rceil$**(不包含失败节点)
- 失败结点:n+1个
- 满足二叉排序树的定义

## 分块查找

特点：块内无序、块间有序

### 数据结构

    //索引表
    typedef struct{
        ElemType maxValue;
        int low,high;
    }Index;

    //顺序表存储实际元素
    ElemType List[100];

### 分块查找，又称索引顺序查找，算法过程如下

1. 在索引表中确定待查元素所属的分块(可顺序、可折半)
2. 在块内顺序查找

#### 用折半查找查索引

- 若索引表中不包括目标关键字，则折半查找索引表最终停在low>high，要在**low所指分块中查找**

  - 原因: 最终low左边一定小于目标关键字，high右边一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字

### 查找效率

假设，长度为n的查找表被均匀地分为b块，每块s个元素  
设索引查找和块内查找的平均查找长度分别为 $L_{I},L_{S}$，则分块查找的平均查找长度为 $$ASL=L_{I}+L{S}$$  

- 用顺序表查索引表，则 $L_{I}=\frac{b+1}{2},L_{S}=\frac{s+1}{2}$  
则 $ASL=\frac{s^{2}+2s+n}{2s}$，当 $s=\sqrt{n}$时，$ASL_{最小}=\sqrt{n}+1$
- 用折半查找查索引表，$ASL=\lceil log_2{b+1} \rceil+\dfrac{s+1}{2}$
