# 树形查找

## 二叉排序树

BST中不允许存在相同值的节点

### 二叉排序树的查找

    //二叉排序树结点
    typedef struct BSTNode{
        int key;
        struct BSTNode *lchild,*rchild;
    }BSTNode,*BSTree;

- 非递归实现：最坏空间复杂度 $O(1)$

         //在二叉排序树中查找值为key的结点
         BSTNode *BST_Search(BSTree T,int key){
             while(T!=NULL&&key!=T->key){
                 if(key<T->key) T=T->lchild;
                 else T=T->rchild;
             }
             return T;
         }

- 递归实现：最坏空间复杂度 $O(h)$

         //在二叉排序树中查找值为key的结点(递归实现)
         BSTNode *BSTSearch(BSTree T,int key){
             if(T==NULL)
                 return NULL;
             if(key==T->key)
                 return T;
             else if(key<T->key)
                 return BSTSearch(T->lchild,key);
             else return BSTSearch(T->rchild,key);
         }

### 二叉排序树的插入

- 递归实现：最坏空间复杂度 $O(h)$

          int BST_Insert(BSTree &T,int k){
              if(T==NULL){
                  T=(BSTree)malloc(sizeof(BSTNode));
                  T->key=k;
                  T->rchild=T->lchild=nullptr;
                  return 1;
              }
              else if(T->key=k)
                  return 0;
              else if(k<T->key) return BST_Insert(T->lchild,k);
              else return BST_Insert(T->rchild,k);
          }

### 二叉排序树的构造

    void Creat_BST(BSTree &T,int str[],int n){
        T=nullptr;
        int i=0;
        while(i<n){
            BST_Insert(T,str[i]);
            i++;
        }
    }

### 二叉排序树的删除

注意中序遍历，和中序线索二叉树的性质

删除结点：
   - 若删除的结点是叶子，直接删
   - 若删除的结点只有一个子树，用子树顶替删除位置
   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。

### 查找效率分析

- 查找成功
  - 最好情况：n个结点的二叉树最小高度为 $\lfloor \log_2{n} \rfloor +1$。平均查找长度= $O(\log_2{n})$
  - 最坏情况：每个结点只有一个分支，树高h=结点数n。平均查找长度= $O(n)$
- 查找失败
  - 补充失败结点

## 平衡二叉树(Balanced Binary Tree)

### 定义

1. 平衡树(AVL树)———树上任一结点的左子树和右子树的高度之差不超过1  
2. 结点的**平衡因子**=左子树高-右子树高

### 平衡二叉树的插入

#### 调整最小不平衡子树(LL)

*LL平衡旋转(右单旋转)*：将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树

#### 调整最小不平衡子树(RR)

*RR平衡旋转(左单选转)*：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树

#### 调整最小不平衡子树(LR)

*LR平衡旋转(先左后右双旋转)*：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置

#### 调整最小不平衡子树(RL)

*RL平衡旋转(先右后左双旋转)*：先将A结点的左孩子B的右子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置

### 查找效率

假设以 $n_{h}$表示深度为h的平衡树中含有的最少的结点树。  
则有 $n_{0}=0,n_{1}=1,n_{2}=2$，并且有 $n_{h}=n_{h-1}+n_{h-2}+1$  
可以证明：含有n个结点的平衡二叉树的最大深度为 $O(\log_2{n})$，平衡二叉树的平均查找长度为 $O(\log_2{n})$

### 平衡二叉树的删除

#### 具体步骤

1. 删除结点
   - 若删除的结点是叶子，直接删
   - 若删除的结点只有一个子树，用子树顶替删除位置
   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。
2. 一路向北找到最小不平衡子树，找不到就完结撒花
3. 找最小不平衡子树下，“个头”最高的儿子、孙子
4. 根据孙子的位置，调整平衡
   - 孙子在LL：儿子右单旋
   - 孙子在RR：儿子左单旋
   - 孙子在LR：孙子先左旋，再右旋
   - 孙子在RL：孙子先右旋，再左旋
5. 如果不平衡向上传导，继续2
   - 对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡(不平衡向上传递)

#### 时间复杂度

$O(\log_2{n})$

## 红黑树(Red-Black Tree,RBT)

### 红黑树的定义

结点定义：

    struct RBNode{
        int key;
        RBNode *parent;
        RBNode *rchild;
        RBNode *lchild;
        int color;
    };

1. 红黑树是一种自平衡的二叉排序树，它允许存在相同值的节点(左 $\leq$根 $\leq$右)
2. 与普通的BST相比，增加的性质有：
   1. 每个结点或是红色的，或是黑色的
   2. 根结点是黑色的
   3. 叶结点(外部结点\NULL结点\失败结点)均是黑色的
   4. 不存在两个相邻的红结点(即红结点的父结点和孩子结点均是黑色)
   5. 对每个结点，从该结点到到任一叶结点的简单路径上，所含黑结点的数目相同
3. 结点的黑高bh———从某结点出发(不含该结点)到达任一空叶结点的路径上的黑叶结点总数
   - 若根节点黑高为h，内部结点数(关键字)最少有 $2^{h}-1$个

### 红黑树的结论

1. 从根节点到叶结点的最长路径不大于最短路径的两倍 $\rightarrow$左右高度相差最大为两倍
   - 证明：任何一条查找失败路径上黑节点数量都相同，而路径上不能连续出现两个红节点，即红节点只能穿插在各个黑节点中间 
2. 有n个内部节点的红黑树高度 $h\leq2\log_2{(n+1)}$ $\rightarrow$红黑树查找操作时间复杂度= $O(\log_2{2})$
   - 证明：若红黑树总高度=h，则根节点黑高 $\geq h/2$，因此内部节点数 $n\geq 2^{h/2}-1$，由此推出 $h \leq 2\log_2{(n+1)}$
3. 查找、删除、插入的时间复杂度均为 $O(\log_2{n})$

### 红黑树的查找

### 红黑树的插入

1. 先查找，确定插入位置(原理同二叉排序树)，插入新结点
2. 新节点是根节点——染为黑色
3. 新节点非根节点——染为红色(使其保持对每个结点，从该结点到到任一叶结点的简单路径上，所含黑结点的数目相同)
4. **只需注意不存在两个相邻的红结点即可**
    - 若插入新节点后依然满足红黑树定义，则插入结束
    - 若插入新节点后不满足红黑树定义，需要调整，使其重新满足红黑树定义
      - 黑叔：旋转+染色
        - LL型：右单旋，父换爷+染色
        - RR型：左单旋，父换爷+染色
        - LR型：左、右双旋，儿换爷+染色
        - RL型：右、左双旋，儿换爷+染色
      - 红叔：染色+变新
        - 叔父爷染色，爷变为新结点

### 红黑树的删除

#### 具体步骤

1. 删除过程也是先执行二叉排序树的删除方法，转化为待删结点是终端节点或仅有一个孩子的情况
   - 若删除的结点是叶子，直接删
   - 若删除的结点只有一个子树，用子树顶替删除位置
   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。
2. 删除一个结点有一下两种情况
   - 待删结点只有右子树或左子树
     - 这种情况下，子树只有一个结点且必然是红色，否则会破坏性质5：将孩子的值复制给它即可
   - 待删结点没有孩子
     - 若该节点是红色的，直接删除，无须调整
     - 若该节点是黑色的。假设待删结点为y，x是用来替换y的结点(注意，当y是终端结点时，x是黑色的NULL结点)。删除y后将导致先前包含y的任何路径上的黑节点数量减1，因此y的任何祖先都不再满足性质5，简单的修正办法就是将替换y的结点x视为还有额外一重黑色，定义为双黑结点。也就是说，如果将任何包含结点x的路径上的黑色结点数量加1，在此假设下，性质5得到满足，但破坏了性质1。于是，删除操作的任务就转化成将双黑结点恢复为普通结点。
     
3. 调整过程
   1. x的兄弟结点w是红色的
      - 交换w和父节点x.p的颜色，然后对w做一次左单旋
   2. x的兄弟结点w是黑色的，且w的右孩子是红色的
      - RR，左单旋，即这个红结点是其爷结点的右孩子的右孩子：交换w和父节点x.p的颜色，把w的右孩子变为黑色，并对w做一次左单旋，将x变为单重黑色。
   3. x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的
      - RL，先右旋再左旋，即这个红结点是其爷结点的右孩子的左孩子：交换w和其左孩子的颜色，然后对w做一次右旋。现在x的新兄弟结点的右孩子是红色的，这样就将情况3转变成了情况2.
   4. x的兄弟结点w是黑色的，且w的两个孩子结点都是黑色的
      - 因w也是黑色的，故可从x和w上去掉一重黑色，使得x只有一重黑色，使得x只有一重黑色而w变为红色。为了补偿从x和w中去掉的一重黑色，把x的父节点x.p额外着一层黑色，以保持局部的黑高不变。通过将x.p作为新结点x来循环，x上升一层。如果是通过情况1进入情况4的，因为原来的x.p是红色的，将新结点x变为黑色，终止循环，结束。
