# 树形查找

## 二叉排序树

### 二叉排序树的查找

    //二叉排序树结点
    typedef struct BSTNode{
        int key;
        struct BSTNode *lchild,*rchild;
    }BSTNode,*BSTree;

- 非递归实现：最坏空间复杂度 $O(1)$
    
         //在二叉排序树中查找值为key的结点
         BSTNode *BST_Search(BSTree T,int key){
             while(T!=NULL&&key!=T->key){
                 if(key<T->key) T=T->lchild;
                 else T=T->rchild;
             }
             return T;
         }

- 递归实现：最坏空间复杂度 $O(h)$

         //在二叉排序树中查找值为key的结点(递归实现)
         BSTNode *BSTSearch(BSTree T,int key){
             if(T==NULL)
                 return NULL;
             if(key==T->key)
                 return T;
             else if(key<T->key)
                 return BSTSearch(T->lchild,key);
             else return BSTSearch(T->rchild,key);
         }

### 二叉排序树的插入

- 递归实现：最坏空间复杂度 $O(h)$

          int BST_Insert(BSTree &T,int k){
              if(T==NULL){
                  T=(BSTree)malloc(sizeof(BSTNode));
                  T->key=k;
                  T->rchild=T->lchild=nullptr;
                  return 1;
              }
              else if(T->key=k)
                  return 0;
              else if(k<T->key) return BST_Insert(T->lchild,k);
              else return BST_Insert(T->rchild,k);
          }

### 二叉排序树的构造

    void Creat_BST(BSTree &T,int str[],int n){
        T=nullptr;
        int i=0;
        while(i<n){
            BST_Insert(T,str[i]);
            i++;
        }
    }

### 二叉排序树的删除

注意中序遍历，和中序线索二叉树的性质

### 查找效率分析

- 查找成功
  - 最好情况：n个结点的二叉树最小高度为 $\lfloor log_{2}n \rfloor +1$。平均查找长度= $O(log_{2}n)$
  - 最坏情况：每个结点只有一个分支，树高h=结点数n。平均查找长度= $O(n)$
- 查找失败
  - 补充失败结点

## 平衡二叉树(Balanced Binary Tree)

### 定义

1. 平衡树(AVL树)———树上任一结点的左子树和右子树的高度之差不超过1  
2. 结点的**平衡因子**=左子树高-右子树高

### 平衡二叉树的插入

#### 调整最小不平衡子树(LL)

*LL平衡旋转(右单旋转)*：将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树

#### 调整最小不平衡子树(RR)

*RR平衡旋转(左单选转)*：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树

#### 调整最小不平衡子树(LR)

*LR平衡旋转(先左后右双旋转)*：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置

#### 调整最小不平衡子树(RL)

*RL平衡旋转(先右后左双旋转)*：先将A结点的左孩子B的右子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置
