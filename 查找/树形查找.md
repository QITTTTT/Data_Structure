# 树形查找

## 二叉排序树

### 二叉排序树的查找

    //二叉排序树结点
    typedef struct BSTNode{
        int key;
        struct BSTNode *lchild,*rchild;
    }BSTNode,*BSTree;

- 非递归实现：最坏空间复杂度 $O(1)$
    
         //在二叉排序树中查找值为key的结点
         BSTNode *BST_Search(BSTree T,int key){
             while(T!=NULL&&key!=T->key){
                 if(key<T->key) T=T->lchild;
                 else T=T->rchild;
             }
             return T;
         }

- 递归实现：最坏空间复杂度 $O(h)$

         //在二叉排序树中查找值为key的结点(递归实现)
         BSTNode *BSTSearch(BSTree T,int key){
             if(T==NULL)
                 return NULL;
             if(key==T->key)
                 return T;
             else if(key<T->key)
                 return BSTSearch(T->lchild,key);
             else return BSTSearch(T->rchild,key);
         }

### 二叉排序树的插入

- 递归实现：最坏空间复杂度 $O(h)$

          int BST_Insert(BSTree &T,int k){
              if(T==NULL){
                  T=(BSTree)malloc(sizeof(BSTNode));
                  T->key=k;
                  T->rchild=T->lchild=nullptr;
                  return 1;
              }
              else if(T->key=k)
                  return 0;
              else if(k<T->key) return BST_Insert(T->lchild,k);
              else return BST_Insert(T->rchild,k);
          }

### 二叉排序树的构造

    void Creat_BST(BSTree &T,int str[],int n){
        T=nullptr;
        int i=0;
        while(i<n){
            BST_Insert(T,str[i]);
            i++;
        }
    }

### 二叉排序树的删除

注意中序遍历，和中序线索二叉树的性质

### 查找效率分析

- 查找成功
  - 最好情况：n个结点的二叉树最小高度为 $\lfloor log_{2}n \rfloor +1$。平均查找长度= $O(log_{2}n)$
  - 最坏情况：每个结点只有一个分支，树高h=结点数n。平均查找长度= $O(n)$
- 查找失败
  - 补充失败结点

## 平衡二叉树(Balanced Binary Tree)

### 定义

1. 平衡树(AVL树)———树上任一结点的左子树和右子树的高度之差不超过1  
2. 结点的**平衡因子**=左子树高-右子树高

### 平衡二叉树的插入

#### 调整最小不平衡子树(LL)

*LL平衡旋转(右单旋转)*：将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树

#### 调整最小不平衡子树(RR)

*RR平衡旋转(左单选转)*：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树

#### 调整最小不平衡子树(LR)

*LR平衡旋转(先左后右双旋转)*：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置

#### 调整最小不平衡子树(RL)

*RL平衡旋转(先右后左双旋转)*：先将A结点的左孩子B的右子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置

### 查找效率分析

假设以 $n_{h}$表示深度为h的平衡树中含有的最少的结点树。  
则有 $n_{0}=0,n_{1}=1,n_{2}=2$，并且有 $n_{h}=n_{h-1}+n_{h-2}+1$  
可以证明：含有n个结点的平衡二叉树的最大深度为 $O(log_{2}n)$，平衡二叉树的平均查找长度为 $O(log_{2}n)$

### 平衡二叉树的删除

#### 具体步骤：

1. 删除结点
   - 若删除的结点是叶子，直接删
   - 若删除的结点只有一个子树，用子树顶替删除位置
   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。
2. 一路向北找到最小不平衡子树，找不到就完结撒花
3. 找最小不平衡子树下，“个头”最高的儿子、孙子
4. 根据孙子的位置，调整平衡
   - 孙子在LL：儿子右单旋
   - 孙子在RR：儿子左单旋
   - 孙子在LR：孙子先左旋，再右旋
   - 孙子在RL：孙子先右旋，再左旋
5. 如果不平衡向上传导，继续2
   - 对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡(不平衡向上传递)

#### 时间复杂度

$O(log_{2}n)$

